# Understanding the Callback Approach: From Broken to Fixed

## What I Originally Attempted

In my first callback fix (`process_realsense_callback.py`), I recognized that the fundamental problem was the mismatch between camera frame rate (30 Hz) and IMU data rate (200 Hz). I understood that to collect all 200 IMU samples per second, I needed a mechanism where the RealSense SDK would automatically notify my code whenever new IMU data arrived, rather than asking for it only 30 times per second. This is the essence of the callback pattern: instead of repeatedly asking "do you have data?" (polling), the hardware system calls a function automatically whenever data is ready. I defined a callback function `imu_callback()` at lines 46-74 that was intended to be invoked automatically by the RealSense SDK every time new IMU data arrived. I also created a large frame queue (`rs.frame_queue(capacity=1000)`) with the idea that this would buffer the high-frequency IMU data while the main loop processed camera frames at a slower rate.

## The Critical Missing Piece

However, I had a fundamental misunderstanding about how callbacks work with the RealSense SDK. Simply defining a callback function does not make it execute automatically - I must explicitly register that function with the sensor hardware. In Python, functions are objects that can be passed around, and when calling `sensor.start(callback_function)`, I am giving the RealSense SDK a reference to my function and telling it "call this function whenever you have new data." My original code defined the callback function but never made this registration call. The RealSense SDK had no knowledge that my `imu_callback()` function existed, so it never called it. The callback function was essentially dead code - it existed in the file but was never executed. This is like writing down a phone number but never giving it to anyone; ready to receive calls, but nobody knows how to reach you.

## The Queue Misunderstanding

Additionally, I created `rs.frame_queue(capacity=1000)` and passed it to `pipeline.start(config, queue)`, thinking this would enable callback-based collection. However, `rs.frame_queue` is not a callback mechanism - it's just a larger buffer for storing frames when using the polling approach. I still had to actively pull frames from this queue using `queue.poll_for_frames()`, and this polling happened inside my main loop which ran at camera frame rate (~30 Hz). The queue gave me a bigger buffer to avoid losing frames during brief processing delays, but it didn't fundamentally change the fact that I was only checking for new data 30 times per second. Even with a 1000-frame queue, if I only poll 30 times per second, I only get 30 samples per second. The queue capacity just determines how many frames can pile up before they start getting dropped - it doesn't affect how frequently I collect data.

## The Pairing Logic Flaw

My original code also attempted to pair accelerometer and gyroscope readings by storing `last_accel` and `last_gyro` variables and only writing to the CSV when both were available. The logic was: if I see an accelerometer frame, store it; if I see a gyroscope frame, store it; when I have both, write them as a pair and reset both variables. The problem with this approach is that it assumed accel and gyro data would arrive in the same frameset or in quick succession. In reality, when calling `pipeline.wait_for_frames()` at 30 Hz, each frameset might contain accel OR gyro or both unpredictably, and I was still fundamentally limited by my 30 Hz polling rate. By resetting the variables after each write, I threw away any solo accel or gyro readings that didn't have a matching pair in that iteration, which meant I still lost most of the 200 Hz data stream.

## The Correct Solution: Actual Callback Registration

The fix required understanding how to properly use the RealSense SDK's callback mechanism. Instead of using the pipeline to manage IMU streams, I needed to access the individual sensors directly and register callback functions with them. First, I obtained the device from the pipeline profile and iterated through all sensors to identify which ones were motion sensors. I then checked each motion sensor to determine whether it was the accelerometer or gyroscope by examining its stream profiles. Once I identified both sensors, I called `accel_sensor.start(accel_callback)` and `gyro_sensor.start(gyro_callback)`. These two lines are what actually registered my callback functions with the RealSense SDK. From that moment on, the SDK's internal background threads would call `accel_callback()` every time the accelerometer produced new data (200 times per second) and `gyro_callback()` every time the gyroscope produced new data (200 times per second), completely independent of my main loop's frame rate.

## How the Callbacks Store Data

Inside the callback functions, I needed to store the incoming data somewhere that the main thread could access later. I used a thread-safe queue (`queue.Queue()`) from Python's standard library, which allows one thread to put data in and another thread to take data out without conflicts. When `accel_callback()` is invoked by the RealSense SDK's background thread, it extracts the motion data and timestamp from the frame, packages it into a dictionary with a type marker ('accel'), and puts it in the queue. The `gyro_callback()` does the same thing with 'gyro' data. This happens asynchronously at 200 Hz in the background while the main thread is busy processing camera frames, saving images, and displaying windows. The queue acts as a buffer that accumulates all the high-frequency IMU data without the main thread needing to be involved at every sample.

## How the Main Loop Processes Queued Data

The main loop continues to run at camera frame rate (~30 Hz), calling `pipeline.wait_for_frames()` to get color and depth images. But now, periodically during each iteration, I call `process_imu_queue_to_csv()` which drains all the accumulated IMU data from the queue and writes it to CSV files. This function reads items from the queue one by one, checks whether each item is 'accel' or 'gyro' type, and writes it to the appropriate CSV file. Since callbacks have been adding data to the queue at 200 Hz while the main loop was busy, there might be 6-7 IMU samples in the queue each time the main loop processes it (200 Hz / 30 Hz â‰ˆ 6.67 samples per frame). The queue decouples the high-frequency data collection (happening in background via callbacks) from the slower image processing (happening in the main loop), allowing both to proceed at their natural rates without interference.

## Why This Works

This approach works because the RealSense SDK manages its own internal threads that read data from the hardware continuously. When I register a callback with `sensor.start(callback)`, I'm telling the SDK to invoke my function from these internal threads whenever new sensor data is ready. My callback executes in the context of the SDK's thread, not my main thread, which is why I need thread-safe data structures like `queue.Queue()` and locks. The callbacks run at the sensor's native rate (200 Hz for IMU) completely independently of what my main program is doing. Even if my main loop gets slow because it's saving large images or doing complex processing, the callbacks keep firing in the background, ensuring no IMU data is lost. The queue buffers any temporary rate mismatches, and my main loop processes the buffered data whenever it gets a chance, eventually catching up and writing everything to disk.
